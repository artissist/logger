#!/usr/bin/env node
// SPDX-License-Identifier: AGPL-3.0-or-later

const fs = require('fs');
const path = require('path');

const MODEL_PATH = path.join(__dirname, '../generated/source/model/model.json');
const OUTPUT_PATH = path.join(__dirname, '../clients/typescript/src/generated-types.ts');
const EMOJI_MAPPINGS_PATH = path.join(__dirname, '../emoji-mappings.json');

// Ensure output directory exists
const outputDir = path.dirname(OUTPUT_PATH);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

// Read and parse the model
const model = JSON.parse(fs.readFileSync(MODEL_PATH, 'utf8'));

// TypeScript type mapping
const typeMap = {
  'smithy.api#String': 'string',
  'smithy.api#Integer': 'number',  
  'smithy.api#Long': 'number',
  'smithy.api#Double': 'number',
  'smithy.api#Boolean': 'boolean',
  'smithy.api#Timestamp': 'Date | string',
  'smithy.api#Document': 'unknown'
};

function mapSmithyType(target) {
  if (typeMap[target]) {
    return typeMap[target];
  }
  
  // Handle custom types - convert fully qualified names to simple names
  if (target.startsWith('artissist.logging#')) {
    return target.replace('artissist.logging#', '');
  }
  
  return 'unknown';
}

function generateStructure(shapeName, shape) {
  const members = shape.members || {};
  let result = `export interface ${shapeName} {\n`;

  for (const [memberName, memberDef] of Object.entries(members)) {
    const isRequired = memberDef.traits && memberDef.traits['smithy.api#required'];
    const optional = isRequired ? '' : '?';
    const baseType = mapSmithyType(memberDef.target);
    // Make all optional fields nullable for user convenience, but avoid redundant union with unknown or Document
    const type = isRequired ? baseType : (baseType === 'unknown' || baseType === 'Document' ? baseType : `${baseType} | null`);
    const doc = memberDef.traits && memberDef.traits['smithy.api#documentation'];

    if (doc) {
      result += `  /** ${doc} */\n`;
    }

    result += `  ${memberName}${optional}: ${type};\n`;
  }

  result += '}\n\n';
  return result;
}

function generateEnum(shapeName, shape) {
  const members = shape.members || {};
  let result = `export enum ${shapeName} {\n`;

  for (const [memberName, memberDef] of Object.entries(members)) {
    const doc = memberDef.traits && memberDef.traits['smithy.api#documentation'];
    const enumValue = memberDef.traits && memberDef.traits['smithy.api#enumValue'];

    if (doc) {
      result += `  /** ${doc} */\n`;
    }

    // Use enumValue if available, otherwise use memberName
    const value = enumValue || memberName;
    result += `  ${memberName} = '${value}',\n`;
  }

  result += '}\n\n';
  return result;
}

function generateList(shapeName, shape) {
  const memberTarget = shape.member ? shape.member.target : 'unknown';
  const elementType = mapSmithyType(memberTarget);
  return `export type ${shapeName} = ${elementType}[];\n\n`;
}

function generateMap(shapeName, shape) {
  const keyTarget = shape.key ? shape.key.target : 'smithy.api#String';
  const valueTarget = shape.value ? shape.value.target : 'smithy.api#String';
  const keyType = mapSmithyType(keyTarget);  
  const valueType = mapSmithyType(valueTarget);
  return `export type ${shapeName} = Record<${keyType}, ${valueType}>;\n\n`;
}

// Generate TypeScript types
let output = `// Generated TypeScript types from Smithy models
// This file is automatically generated. Do not edit directly.

// Document type for arbitrary JSON data
export type Document = unknown;

`;

// Process shapes
const artissistShapes = {};
for (const [fullShapeName, shape] of Object.entries(model.shapes)) {
  if (fullShapeName.startsWith('artissist.logging#')) {
    const shapeName = fullShapeName.replace('artissist.logging#', '');
    artissistShapes[shapeName] = shape;
  }
}

// Generate types in order: basic types first, then complex ones
const basicTypes = ['LogLevel', 'LogEvent', 'ServiceName', 'Environment', 'LogId', 'UserId', 'SessionId', 'RequestId', 'Timestamp', 'TimestampFormat', 'AdapterName'];
const listTypes = ['LogEntryList', 'LogIdList', 'FailedLogEntryList', 'AdapterNameList'];
const mapTypes = ['TagMap', 'MetricsMap', 'CustomEventMap', 'EmojiMappingMap'];

// Generate basic enums and strings first
for (const typeName of basicTypes) {
  if (artissistShapes[typeName]) {
    const shape = artissistShapes[typeName];
    if (shape.type === 'enum') {
      output += generateEnum(typeName, shape);
    } else if (shape.type === 'string' || shape.type === 'timestamp') {
      const baseType = shape.type === 'timestamp' ? 'Date | string' : 'string';
      output += `export type ${typeName} = ${baseType};\n\n`;
    }
    delete artissistShapes[typeName];
  }
}

// Generate list types
for (const typeName of listTypes) {
  if (artissistShapes[typeName]) {
    output += generateList(typeName, artissistShapes[typeName]);
    delete artissistShapes[typeName];
  }
}

// Generate map types
for (const typeName of mapTypes) {
  if (artissistShapes[typeName]) {
    output += generateMap(typeName, artissistShapes[typeName]);
    delete artissistShapes[typeName];
  }
}

// Generate remaining structures
for (const [shapeName, shape] of Object.entries(artissistShapes)) {
  if (shape.type === 'structure') {
    output += generateStructure(shapeName, shape);
  }
}

// Extract and generate emoji mappings
function generateEmojiMappings() {
  if (!fs.existsSync(EMOJI_MAPPINGS_PATH)) {
    return '';
  }

  const mappings = JSON.parse(fs.readFileSync(EMOJI_MAPPINGS_PATH, 'utf8'));
  let emojiMappings = '';

  emojiMappings += `// Standardized emoji mappings - BREAKING CHANGE: emojis are now consistent across languages\n`;
  emojiMappings += `export const DEFAULT_EMOJI_MAPPINGS: Record<string, { emoji: string; description: string; isDefault: boolean }> = {\n`;

  for (const [event, config] of Object.entries(mappings)) {
    emojiMappings += `  ${event}: {\n`;
    emojiMappings += `    emoji: "${config.emoji}",\n`;
    emojiMappings += `    description: "${config.description}",\n`;
    emojiMappings += `    isDefault: ${config.isDefault}\n`;
    emojiMappings += `  },\n`;
  }

  emojiMappings += '};\n\n';

  // Also generate typed version based on LogEvent enum
  emojiMappings += `// Type-safe emoji mappings using LogEvent enum\n`;
  emojiMappings += `export const TYPED_EMOJI_MAPPINGS: Record<LogEvent, { emoji: string; description: string; isDefault: boolean }> = {\n`;

  for (const [event, config] of Object.entries(mappings)) {
    emojiMappings += `  [LogEvent.${event}]: {\n`;
    emojiMappings += `    emoji: "${config.emoji}",\n`;
    emojiMappings += `    description: "${config.description}",\n`;
    emojiMappings += `    isDefault: ${config.isDefault}\n`;
    emojiMappings += `  },\n`;
  }

  emojiMappings += '};\n\n';

  return emojiMappings;
}

// Add emoji mappings to output
const emojiMappings = generateEmojiMappings();
if (emojiMappings) {
  output += emojiMappings;
}

// Write the generated file
fs.writeFileSync(OUTPUT_PATH, output);
console.log(`âœ… Generated TypeScript types: ${OUTPUT_PATH}`);
console.log(`ðŸ“Š Generated ${Object.keys(model.shapes).filter(name => name.startsWith('artissist.logging#')).length} types`);
if (emojiMappings) {
  console.log(`ðŸŽ¨ Generated standardized emoji mappings`);
}