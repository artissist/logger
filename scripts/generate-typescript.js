#!/usr/bin/env node
// SPDX-License-Identifier: AGPL-3.0-or-later

const fs = require('fs');
const path = require('path');

const MODEL_PATH = path.join(__dirname, '../generated/source/model/model.json');
const OUTPUT_PATH = path.join(__dirname, '../generated/typescript/types.ts');

// Ensure output directory exists
const outputDir = path.dirname(OUTPUT_PATH);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

// Read and parse the model
const model = JSON.parse(fs.readFileSync(MODEL_PATH, 'utf8'));

// TypeScript type mapping
const typeMap = {
  'smithy.api#String': 'string',
  'smithy.api#Integer': 'number',  
  'smithy.api#Long': 'number',
  'smithy.api#Double': 'number',
  'smithy.api#Boolean': 'boolean',
  'smithy.api#Timestamp': 'Date | string',
  'smithy.api#Document': 'unknown'
};

function mapSmithyType(target) {
  if (typeMap[target]) {
    return typeMap[target];
  }
  
  // Handle custom types - convert fully qualified names to simple names
  if (target.startsWith('mosaic.logging#')) {
    return target.replace('mosaic.logging#', '');
  }
  
  return 'unknown';
}

function generateStructure(shapeName, shape) {
  const members = shape.members || {};
  let result = `export interface ${shapeName} {\n`;
  
  for (const [memberName, memberDef] of Object.entries(members)) {
    const isRequired = memberDef.traits && memberDef.traits['smithy.api#required'];
    const optional = isRequired ? '' : '?';
    const type = mapSmithyType(memberDef.target);
    const doc = memberDef.traits && memberDef.traits['smithy.api#documentation'];
    
    if (doc) {
      result += `  /** ${doc} */\n`;
    }
    
    result += `  ${memberName}${optional}: ${type};\n`;
  }
  
  result += '}\n\n';
  return result;
}

function generateEnum(shapeName, shape) {
  const members = shape.members || {};
  let result = `export enum ${shapeName} {\n`;
  
  for (const [memberName, memberDef] of Object.entries(members)) {
    const doc = memberDef.traits && memberDef.traits['smithy.api#documentation'];
    
    if (doc) {
      result += `  /** ${doc} */\n`;
    }
    
    result += `  ${memberName} = '${memberName}',\n`;
  }
  
  result += '}\n\n';
  return result;
}

function generateList(shapeName, shape) {
  const memberTarget = shape.member ? shape.member.target : 'unknown';
  const elementType = mapSmithyType(memberTarget);
  return `export type ${shapeName} = ${elementType}[];\n\n`;
}

function generateMap(shapeName, shape) {
  const keyTarget = shape.key ? shape.key.target : 'smithy.api#String';
  const valueTarget = shape.value ? shape.value.target : 'smithy.api#String';
  const keyType = mapSmithyType(keyTarget);  
  const valueType = mapSmithyType(valueTarget);
  return `export type ${shapeName} = Record<${keyType}, ${valueType}>;\n\n`;
}

// Generate TypeScript types
let output = `// Generated TypeScript types from Smithy models
// This file is automatically generated. Do not edit directly.

`;

// Process shapes
const mosaicShapes = {};
for (const [fullShapeName, shape] of Object.entries(model.shapes)) {
  if (fullShapeName.startsWith('mosaic.logging#')) {
    const shapeName = fullShapeName.replace('mosaic.logging#', '');
    mosaicShapes[shapeName] = shape;
  }
}

// Generate types in order: basic types first, then complex ones
const basicTypes = ['LogLevel', 'LogEvent', 'ServiceName', 'Environment', 'LogId', 'UserId', 'SessionId', 'RequestId', 'Timestamp'];
const listTypes = ['LogEntryList', 'LogIdList', 'FailedLogEntryList'];  
const mapTypes = ['TagMap', 'MetricsMap', 'CustomEventMap'];

// Generate basic enums and strings first
for (const typeName of basicTypes) {
  if (mosaicShapes[typeName]) {
    const shape = mosaicShapes[typeName];
    if (shape.type === 'enum') {
      output += generateEnum(typeName, shape);
    } else if (shape.type === 'string' || shape.type === 'timestamp') {
      const baseType = shape.type === 'timestamp' ? 'Date | string' : 'string';
      output += `export type ${typeName} = ${baseType};\n\n`;
    }
    delete mosaicShapes[typeName];
  }
}

// Generate list types
for (const typeName of listTypes) {
  if (mosaicShapes[typeName]) {
    output += generateList(typeName, mosaicShapes[typeName]);
    delete mosaicShapes[typeName];
  }
}

// Generate map types
for (const typeName of mapTypes) {
  if (mosaicShapes[typeName]) {
    output += generateMap(typeName, mosaicShapes[typeName]);
    delete mosaicShapes[typeName];
  }
}

// Generate remaining structures
for (const [shapeName, shape] of Object.entries(mosaicShapes)) {
  if (shape.type === 'structure') {
    output += generateStructure(shapeName, shape);
  }
}

// Write the generated file
fs.writeFileSync(OUTPUT_PATH, output);
console.log(`âœ… Generated TypeScript types: ${OUTPUT_PATH}`);
console.log(`ðŸ“Š Generated ${Object.keys(model.shapes).filter(name => name.startsWith('mosaic.logging#')).length} types`);