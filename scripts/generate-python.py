#!/usr/bin/env python3
# SPDX-License-Identifier: AGPL-3.0-or-later

"""
Generate Python types from Smithy model JSON
"""

import json
import os
from pathlib import Path
from typing import Dict, Any


def to_python_type(target: str) -> str:
    """Map Smithy type to Python type annotation"""
    type_map = {
        "smithy.api#String": "str",
        "smithy.api#Integer": "int",
        "smithy.api#Long": "int",
        "smithy.api#Double": "float",
        "smithy.api#Float": "float",
        "smithy.api#Boolean": "bool",
        "smithy.api#Timestamp": "str",
        "smithy.api#Document": "Any",
    }

    if target in type_map:
        return type_map[target]

    # Handle custom types - convert fully qualified names to simple names
    if target.startswith("artissist.logging#"):
        return target.replace("artissist.logging#", "")

    return "Any"


def to_snake_case(name: str) -> str:
    """Convert PascalCase to snake_case"""
    import re

    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()


def generate_enum(shape_name: str, shape: Dict[str, Any]) -> str:
    """Generate Python Enum class"""
    members = shape.get("members", {})

    result = f"class {shape_name}(Enum):\n"
    result += f'    """{shape.get("traits", {}).get("smithy.api#documentation", f"{shape_name} enum")}"""\n\n'

    for member_name, member_def in members.items():
        doc = member_def.get("traits", {}).get("smithy.api#documentation")
        if doc:
            result += f"    # {doc}\n"
        result += f'    {member_name} = "{member_name}"\n'

    result += "\n\n"
    return result


def generate_dataclass(shape_name: str, shape: Dict[str, Any]) -> str:
    """Generate Python dataclass"""
    members = shape.get("members", {})

    result = f"@dataclass\n"
    result += f"class {shape_name}:\n"
    result += f'    """{shape.get("traits", {}).get("smithy.api#documentation", f"{shape_name} data structure")}"""\n\n'

    for member_name, member_def in members.items():
        is_required = member_def.get("traits", {}).get("smithy.api#required", False)
        python_type = to_python_type(member_def["target"])
        snake_name = to_snake_case(member_name)
        doc = member_def.get("traits", {}).get("smithy.api#documentation")

        # Use string annotation for forward references
        if python_type not in ("str", "int", "float", "bool", "Any"):
            python_type = f'"{python_type}"'

        if doc:
            result += f"    # {doc}\n"

        if is_required:
            result += f"    {snake_name}: {python_type}\n"
        else:
            result += f"    {snake_name}: Optional[{python_type}] = None\n"

    result += "\n\n"
    return result


def generate_type_alias(shape_name: str, shape: Dict[str, Any]) -> str:
    """Generate Python type alias"""
    if shape["type"] == "list":
        element_type = to_python_type(shape["member"]["target"])
        # Use string annotation for forward references
        if element_type not in ("str", "int", "float", "bool", "Any"):
            element_type = f'"{element_type}"'
        return f"{shape_name} = List[{element_type}]\n\n"
    elif shape["type"] == "map":
        key_type = to_python_type(
            shape.get("key", {}).get("target", "smithy.api#String")
        )
        value_type = to_python_type(
            shape.get("value", {}).get("target", "smithy.api#String")
        )
        # Use string annotation for forward references
        if value_type not in ("str", "int", "float", "bool", "Any"):
            value_type = f'"{value_type}"'
        return f"{shape_name} = Dict[{key_type}, {value_type}]\n\n"
    else:
        target_type = to_python_type(shape.get("target", "smithy.api#String"))
        return f"{shape_name} = {target_type}\n\n"


def main():
    # Read the Smithy model JSON
    script_dir = Path(__file__).parent
    model_path = script_dir / "../generated/source/model/model.json"
    output_path = script_dir / "../clients/python/artissist_logger/generated_types.py"

    with open(model_path, "r") as f:
        model = json.load(f)

    shapes = model["shapes"]

    # Generate Python code
    output = '''# SPDX-License-Identifier: AGPL-3.0-or-later
"""
Generated Python types from Smithy models
This file is automatically generated. Do not edit directly.
"""

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional, Union

# Document type for arbitrary JSON data
Document = Any


'''

    # Generate types in order: enums first, then type aliases, then dataclasses
    artissist_shapes = {}
    for full_shape_name, shape in shapes.items():
        if full_shape_name.startswith("artissist.logging#"):
            shape_name = full_shape_name.replace("artissist.logging#", "")
            artissist_shapes[shape_name] = shape

    # Generate enums
    for shape_name, shape in artissist_shapes.items():
        if shape["type"] == "enum":
            output += generate_enum(shape_name, shape)

    # Generate type aliases
    basic_types = [
        "ServiceName",
        "Environment",
        "LogId",
        "UserId",
        "SessionId",
        "RequestId",
        "Timestamp",
    ]
    list_types = ["LogEntryList", "LogIdList", "FailedLogEntryList", "AdapterNameList"]
    map_types = ["TagMap", "MetricsMap", "CustomEventMap", "EmojiMappingMap"]

    for type_name in basic_types + list_types + map_types:
        if type_name in artissist_shapes:
            output += generate_type_alias(type_name, artissist_shapes[type_name])

    # Generate dataclasses
    for shape_name, shape in artissist_shapes.items():
        if shape["type"] == "structure":
            output += generate_dataclass(shape_name, shape)

    # Extract and generate emoji mappings
    def generate_emoji_mappings():
        emoji_mappings_path = script_dir / "../emoji-mappings.json"

        if not emoji_mappings_path.exists():
            return ""

        with open(emoji_mappings_path, "r") as f:
            mappings = json.load(f)

        emoji_mappings = ""
        emoji_mappings += "\n# Standardized emoji mappings - BREAKING CHANGE:\n"
        emoji_mappings += "# emojis are now consistent across languages\n"
        emoji_mappings += (
            "DEFAULT_EMOJI_MAPPINGS: Dict[str, Dict[str, Union[str, bool]]] = {\n"
        )

        for event, config in mappings.items():
            emoji_mappings += f'    "{event}": {{\n'
            emoji_mappings += f'        "emoji": "{config["emoji"]}",\n'
            emoji_mappings += f'        "description": "{config["description"]}",\n'
            emoji_mappings += (
                f'        "is_default": {str(config["isDefault"]).title()}\n'
            )
            emoji_mappings += "    },\n"

        emoji_mappings += "}\n\n"

        # Also generate typed version
        emoji_mappings += "# Type-safe emoji mappings using LogEvent enum\n"
        emoji_mappings += (
            "TYPED_EMOJI_MAPPINGS: Dict[LogEvent, Dict[str, Union[str, bool]]] = {\n"
        )

        for event, config in mappings.items():
            emoji_mappings += f"    LogEvent.{event}: {{\n"
            emoji_mappings += f'        "emoji": "{config["emoji"]}",\n'
            emoji_mappings += f'        "description": "{config["description"]}",\n'
            emoji_mappings += (
                f'        "is_default": {str(config["isDefault"]).title()}\n'
            )
            emoji_mappings += "    },\n"

        emoji_mappings += "}\n\n"

        return emoji_mappings

    # Add emoji mappings to output
    emoji_mappings = generate_emoji_mappings()
    if emoji_mappings:
        output += emoji_mappings

    # Write the generated file
    os.makedirs(output_path.parent, exist_ok=True)
    with open(output_path, "w") as f:
        f.write(output)

    print(f"âœ… Generated Python types: {output_path}")
    print(
        f'ðŸ“Š Generated {len([name for name in shapes.keys() if name.startswith("artissist.logging#")])} types'
    )
    if emoji_mappings:
        print("ðŸŽ¨ Generated standardized emoji mappings")


if __name__ == "__main__":
    main()
